# Copyright  :  (C) 2021-2022, QBayLogic B.V.,
#                   2022     , Google Inc
# License    :  BSD2 (see the file LICENSE)
# Maintainer :  QBayLogic B.V. <devops@qbaylogic.com>
#
# Script to parse output generated by Clash to use in the synthesis tool.
#
# TODO: More user documentation

package require json

namespace eval clash {
    variable metadata
    variable topEntity

    proc readMetadata topEntityDir {
        variable metadata
        variable topEntity

        proc ParseManifest {entityDir withDeps} {
            variable metadata

            set manC [open [file join $entityDir clash-manifest.json] r]
            set manifest [json::json2dict [read $manC]]
            close $manC
            set lib [dict get $manifest top_component name]
            puts "New top component: $lib"
            dict set metadata $lib hdlFiles {}
            dict set metadata $lib constraintFiles {}
            foreach fileEntry [dict get $manifest files] {
                set name [file join $entityDir [dict get $fileEntry name]]
                if {
                       [string match {*.vhdl} $name]
                    || [string match {*.v} $name]
                    || [string match {*.sv} $name]
                } then {
                    dict with metadata $lib {
                        lappend hdlFiles $name
                    }
                } elseif {
                       [string match {*.sdc} $name]
                    || [string match {*.xdc} $name]
                } then {
                    dict with metadata $lib {
                        lappend constraintFiles $name

                    }
                }
            }
            if {!$withDeps} {
                return $lib
            }

            set dependencies {}
            foreach dependency [dict get $manifest dependencies transitive] {
                lappend dependencies [ParseManifest [file join \
                        [file dirname $entityDir] $dependency] False]
            }
            dict set metadata $lib dependencies $dependencies
            return $lib
        }

        set metadata [dict create]
        set topEntity [ParseManifest $topEntityDir True]
        puts "Top entity is $topEntity"
        return
    }

    proc readHdl {} {
        variable metadata
        variable topEntity

        proc OneLib lib {
            variable metadata

            foreach hdlFile [dict get $metadata $lib hdlFiles] {
                if {[string match {*.vhdl} $hdlFile]} {
                    read_vhdl -library $lib $hdlFile
                } elseif {[string match {*.v} $hdlFile]} {
                    read_verilog $hdlFile
                } elseif {[string match {*.sv} $hdlFile]} {
                    read_verilog -sv $hdlFile
                } else {
                    error "Error: Unknown extension on HDL file $hdlFile"
                }
            }
            return
        }

        foreach dependency \
                [lreverse [dict get $metadata $topEntity dependencies]] {
            OneLib $dependency
        }
        OneLib $topEntity
    }

    proc readXdc {} {
        variable metadata
        variable topEntity

        foreach constraintFile [dict get $metadata $topEntity constraintFiles] {
            read_xdc $constraintFile
        }
    }
}
